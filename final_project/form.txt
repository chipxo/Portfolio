import { RootState } from "@/app/rootReducer.tsx";
import { useAppDispatch } from "@/app/store.tsx";
import { showPasswordIcon } from "@/components/common/icons.tsx";
import { Button } from "@/components/ui/button.tsx";
import { Input } from "@/components/ui/input.tsx";
import { setAlertText, showAlert } from "@/features/alert/alertSlice.tsx";
import {
  setRegistered,
  setSignedIn,
  showForm,
} from "@/features/registration/registerSlice.tsx";
import { mOpacity } from "@/utils/motionSettings.tsx";
import { zodResolver } from "@hookform/resolvers/zod";
import { motion as m } from "framer-motion";
import { useState } from "react";
import { SubmitHandler, useForm } from "react-hook-form";
import { useSelector } from "react-redux";
import { twJoin } from "tailwind-merge";
import { z } from "zod";
import FormHeader from "./FormHeader";
import axios from "axios";
import { CREATE_USER } from "@/api/api";
import registerUser from "@/hooks/register";
import signIn from "@/hooks/signIn";

const signUpSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters" }),
  email: z
    .string()
    .min(4, { message: "Email must be at least 4 characters" })
    .email({ message: "Must be a valid email" }),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .refine((value) => /\d/.test(value), {
      message: "Password must include at least one numeric character",
    }),
});

type TSignUpSchema = z.infer<typeof signUpSchema>;

const Form = () => {
  const dispatch = useAppDispatch();

  const { alreadyRegistered, data, loading, error } = useSelector(
    (state: RootState) => state.register,
  );

  const [showPassword, setShowPassword] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<TSignUpSchema>({
    resolver: zodResolver(signUpSchema),
  });

  // const onSubmit: SubmitHandler<TSignUpSchema> = ({
  //   name,
  //   email,
  //   password,
  // }) => {
  //   const userDataString = localStorage.getItem(`user-${email}`);
  //   const userExist = userDataString ? JSON.parse(userDataString) : null;

  //   const createUser = async () => {
  //     try {
  //       const url = CREATE_USER;

  //       const response = await axios.post(
  //         url,
  //         {
  //           name: name,
  //           email: email,
  //           password: password,
  //           avatar: "https://i.imgur.com/LDOO4Qs.jpg",
  //         },
  //         {
  //           headers: {
  //             "Content-Type": "application/json",
  //           },
  //         },
  //       );

  //       if (response.status === 201) {
  //         localStorage.setItem(`${email}`, `${name}`);
  //         dispatch(setAlertText("You successfully registered!"));

  //         dispatch(showAlert(true));
  //       } else {
  //         dispatch(setAlertText("You successfully registered!"));

  //         dispatch(showAlert(true));
  //       }

  //       console.log(response);
  //       return response.data;
  //     } catch (e) {
  //       if (axios.isAxiosError(e)) {
  //         console.log("Axios error:", e.response ? e.response.data : e.message);
  //       } else {
  //         console.log("Error:", e);
  //       }
  //     }
  //   };

  //   createUser();

  //   setTimeout(() => {
  //     if (alreadyRegistered) {
  //       if (userExist && userExist.password === password) {
  //         // if user exists and pass the right password, it makes him signed in, close the form and give the access
  //         // to user panel
  //         localStorage.setItem("signedIn", JSON.stringify("true"));

  //         dispatch(setSignedIn(true));

  //         dispatch(showForm(false));
  //         document.body?.removeAttribute("class");

  //         dispatch(setAlertText("You successfully signed in!"));
  //         dispatch(showAlert(true));
  //       } else if (userExist && userExist.password !== password) {
  //         //if user pass wrong password = alert wrong password and reset the form
  //         dispatch(setAlertText("Wrong password, try again!"));
  //         dispatch(showAlert(true));
  //       } else {
  //         //if user pass wrong email
  //         dispatch(setAlertText("User doesnt exist, try again!"));
  //         dispatch(showAlert(true));
  //       }
  //     } else {
  //       if (userExist) {
  //         //if user try to registrate with existing email
  //         dispatch(setAlertText("User already exist, try again!"));
  //         dispatch(showAlert(true));
  //       } else {
  //         //if user successfully registrated
  //         localStorage.setItem(
  //           `user-${email}`,
  //           JSON.stringify({ name, email, password }),
  //         );

  //         localStorage.setItem("userData", JSON.stringify({ name, email }));

  //         dispatch(showForm(false));
  //         document.body?.removeAttribute("class");

  //         dispatch(setAlertText("You successfully registered!"));
  //         dispatch(showAlert(true));
  //       }
  //     }
  //     reset();
  //   }, 1000);
  // };
  const onSubmit: SubmitHandler<TSignUpSchema> = ({
    name,
    email,
    password,
  }) => {
    const userEmail = localStorage.getItem(`${email}`);
    setTimeout(() => {
      if (alreadyRegistered) {
        dispatch(signIn({ email, password }));

        if (!error) {
          dispatch(showForm(false));
          dispatch(setSignedIn(true));
          dispatch(setAlertText("You successfully signed in!"));
          dispatch(showAlert(true));
          localStorage.setItem("signedIn", "true");
        } else {
          dispatch(setAlertText("User doesnt exist, try again"));
          dispatch(showAlert(true));
        }
      } else {
        if (!userEmail) {
          dispatch(registerUser({ name, email, password }));
          reset();

          if (!error) {
            dispatch(setRegistered(true));
            dispatch(setAlertText("You successfully registered!"));
            dispatch(showAlert(true));
            dispatch(showForm(false));
            localStorage.setItem(`${email}`, `${name}`);
          } else {
            dispatch(setAlertText("Error, try again!"));
            dispatch(showAlert(true));
          }
        } else {
          reset();
          dispatch(setAlertText("User is already registered!"));
          dispatch(showAlert(true));
        }
      }
    }, 1000);
  };

  return (
    <m.div
      {...mOpacity}
      className="fixed inset-0 z-[200] grid items-center bg-black/70 px-4"
    >
      <div className="relative left-1/2 -translate-x-1/2 rounded-md bg-background max-md:container md:max-w-[45vw] xl:max-w-[35vw]">
        <FormHeader reset={reset} />

        <form onSubmit={handleSubmit(onSubmit)}>
          <div className="grid gap-y-14 border-b px-6 py-8">
            <label htmlFor="name" className="relative">
              <span className="absolute -top-6 text-sm opacity-60">Name</span>
              <Input
                {...register("name")}
                type="text"
                name="name"
                id="name"
                className={twJoin(
                  "w-full rounded-md border bg-transparent p-2",
                  errors.name ? "border-red-600" : "border-neutral",
                )}
              />
              {errors.name && (
                <p className="absolute top-11 text-red-600">{`${errors.name.message}`}</p>
              )}
            </label>
            <label htmlFor="email" className="relative">
              <span className="absolute -top-6 text-sm opacity-60">Email</span>
              <Input
                {...register("email")}
                type="text"
                name="email"
                id="email"
                className={twJoin(
                  "w-full rounded-md border bg-transparent p-2",
                  errors.email ? "border-red-600" : "border-neutral",
                )}
              />
              {errors.email && (
                <p className="absolute top-11 text-red-600">{`${errors.email.message}`}</p>
              )}
            </label>
            <label htmlFor="password" className="relative">
              <span className="absolute -top-6 text-sm opacity-60">
                Password
              </span>
              <Input
                {...register("password")}
                type={`${showPassword ? "text" : "password"}`}
                name="password"
                id="password"
                className={twJoin(
                  "w-full rounded-md border bg-transparent p-2",
                  errors.password ? "border-red-600" : "border-neutral",
                )}
              />

              {/* Icon to show/hide password  */}
              <span
                onClick={() => setShowPassword(!showPassword)}
                className={twJoin(
                  "absolute right-2 top-2 cursor-pointer",
                  !showPassword &&
                    "before:bg-base-300 opacity-30 before:absolute before:top-[10px] before:h-[2px] before:w-5 before:-rotate-45",
                )}
              >
                {showPasswordIcon}
              </span>
              {errors.password && (
                <p className="absolute top-11 text-red-600">{`${errors.password.message}`}</p>
              )}
            </label>
          </div>
          <div className="grid gap-4 px-6 py-4 text-sm">
            {/* Submitting button */}
            <Button>{alreadyRegistered ? "Sign in" : "Register"}</Button>
          </div>
        </form>
      </div>
    </m.div>
  );
};

export default Form;

import register from "@/hooks/register";
import signIn from "@/hooks/signIn";
import { User } from "@/types/types";
import { PayloadAction, createSlice } from "@reduxjs/toolkit";

type InitialState = {
  alreadyRegistered: boolean;
  signedIn: boolean;
  openForm: boolean;
  openUserPanel: boolean;
  data: User | null;
  loading: boolean;
  error: string | {} | null;
};

const initialState: InitialState = {
  alreadyRegistered: true,
  signedIn: false,
  openForm: false,
  openUserPanel: false,
  data: null,
  loading: false,
  error: null,
};

const registerSlice = createSlice({
  name: "register",
  initialState,
  reducers: {
    setRegistered: (state, action: PayloadAction<boolean>) => {
      state.alreadyRegistered = action.payload;
    },
    setSignedIn: (state, action: PayloadAction<boolean>) => {
      state.signedIn = action.payload;
    },
    showForm: (state, action: PayloadAction<boolean>) => {
      state.openForm = action.payload;
    },
    showUserPanel: (state, action: PayloadAction<boolean>) => {
      state.openUserPanel = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(register.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action) => {
        state.loading = false;
        state.error = null;

        state.data = action.payload;
      })
      .addCase(register.rejected, (state, action) => {
        state.error = action.payload ?? "Fetch failed";
        state.loading = false;
      })
      .addCase(signIn.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(signIn.fulfilled, (state, action) => {
        state.loading = false;
        state.error = null;

        // state.data = action.payload;
      })
      .addCase(signIn.rejected, (state, action) => {
        state.error = action.payload ?? "Fetch failed";
        state.loading = false;
      });
  },
});

export const { setRegistered, setSignedIn, showForm, showUserPanel } =
  registerSlice.actions;
//setUserData,

export default registerSlice.reducer;

import { CONFIG, CREATE_USER } from "@/api/api";
import { User } from "@/types/types";
import { createAsyncThunk } from "@reduxjs/toolkit";
import axios, { AxiosResponse } from "axios";

const register = createAsyncThunk(
  "register/register",
  async ({ name, email, password }: User) => {
    try {
      const url = CREATE_USER;

      const userData = {
        name: name,
        email: email,
        password: password,
        avatar:
          "https://th.bing.com/th/id/OIP.8az-UgzRmN0j6OXHOoHXXgHaE8?rs=1&pid=ImgDetMain",
      };

      const { data } = await axios.post(url, userData, CONFIG);
      console.log(data);

      return data;
    } catch (e) {
      if (axios.isAxiosError(e)) {
        console.log(`Axios error: ${e}`);
      } else {
        console.log(e);
        throw new Error("Registration failed");
      }
    }
  },
);

export default register;
import { CONFIG, SIGN_IN } from "@/api/api";
import { User } from "@/types/types";
import { createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

const signIn = createAsyncThunk(
  "register/signIn",
  async ({ email, password }: User) => {
    try {
      const url = SIGN_IN;
      const userData = {
        email: email,
        password: password,
      };

      const { data } = await axios.post(url, userData, {
        headers: {
          "Content-Type": "application/json",
        },
      });

      console.log(data);

      return data;
    } catch (e) {
      if (axios.isAxiosError(e)) {
        console.log(`Axios error: ${e}`);
      } else {
        console.log(e);
        throw new Error("Sign in failed");
      }
    }
  },
);

export default signIn;
export type User = Record<string, string | number>;

import register from "@/hooks/register";
import signIn from "@/hooks/signIn";
import { User } from "@/types/types";
import { PayloadAction, createSlice } from "@reduxjs/toolkit";

type InitialState = {
  alreadyRegistered: boolean;
  signedIn: boolean;
  openForm: boolean;
  openUserPanel: boolean;
  data: User | null;
  loading: boolean;
  error: string | {} | null;
};

const initialState: InitialState = {
  alreadyRegistered: true,
  signedIn: false,
  openForm: false,
  openUserPanel: false,
  data: null,
  loading: false,
  error: null,
};

const registerSlice = createSlice({
  name: "register",
  initialState,
  reducers: {
    setRegistered: (state, action: PayloadAction<boolean>) => {
      state.alreadyRegistered = action.payload;
    },
    setSignedIn: (state, action: PayloadAction<boolean>) => {
      state.signedIn = action.payload;
    },
    showForm: (state, action: PayloadAction<boolean>) => {
      state.openForm = action.payload;
    },
    showUserPanel: (state, action: PayloadAction<boolean>) => {
      state.openUserPanel = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(register.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action) => {
        state.loading = false;
        state.error = null;

        state.data = action.payload;
      })
      .addCase(register.rejected, (state, action) => {
        state.error = action.payload ?? "Fetch failed";
        state.loading = false;
      })
      .addCase(signIn.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(signIn.fulfilled, (state, action) => {
        state.loading = false;
        state.error = null;

        // state.data = action.payload;
      })
      .addCase(signIn.rejected, (state, action) => {
        state.error = action.payload ?? "Fetch failed";
        state.loading = false;
      });
  },
});

export const { setRegistered, setSignedIn, showForm, showUserPanel } =
  registerSlice.actions;
//setUserData,

export default registerSlice.reducer;
